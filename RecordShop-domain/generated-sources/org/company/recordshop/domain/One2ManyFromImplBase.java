
/**
 * DO NOT MODIFY THIS FILE, CHANGES WILL BE AUTOMATICALLY OVERWRITTEN! 
 *
 * Generated by Mod4j. 
 *     Time             : Fri Jun 10 13:47:11 CEST 2011
 *     Application model: One2ManyFrom
 *     Generator        : Mod4j BusinessDomainDsl generator: NewJavaBean.xpt
 */

package org.company.recordshop.domain;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.mod4j.runtime.validation.BusinessRuleValidationSupport;
import org.mod4j.runtime.validation.NotNullValidator;

/**
 * This class has no meaning in the recordshop application. Its purpose is to test
ordered one-to-many associations
 *
 * @author Generated by Mod4j BusinessDomain DSL
 */
@SuppressWarnings("serial")
public abstract class One2ManyFromImplBase implements java.io.Serializable {

	/**
	 * validation : Responsible for validating attribute constraints and businessrules for this business class.
	 * 
	 */
	protected BusinessRuleValidationSupport validation = new BusinessRuleValidationSupport(
			this);

	/**
	 *  id: The identifier of this object.
	 */
	private Long id;

	/**
	 *
	 * @return id (Long) The identifier of this object.
	 */
	public Long getId() {
		return this.id;
	}

	/**
	 * version: The version of this object 
	 */
	private int version = -1;

	/**
	 * @return version (Integer) The version of this object.
	 */
	public Integer getVersion() {
		return this.version;
	}

	/**
	 * toString method for One2ManyFromImplBase
	 */
	@Override
	public String toString() {
		StringBuffer result = new StringBuffer();
		result.append("org.company.recordshop.domain.One2ManyFrom[");
		result.append("id=");
		result.append(getId());
		result.append(",");
		result.append("version=");
		result.append(getVersion());

		result.append(",");
		result.append("property=");
		result.append(property);

		result.append("]");
		return result.toString();
	}

	/**
	 *  property: 
	 */
	protected String property;

	/**
	 *  target: This Association has no meaning in the recordshop application. Its purpose is to test
	uni-directional many-to-many associations
	 */
	private List<One2ManyOrderedTo> target = new ArrayList<One2ManyOrderedTo>();

	/**
	 * @param id
	 *        id of the collection element to return
	 *
	 * @return target (One2ManyOrderedTo)
	 *         with the given id.
	 */
	public One2ManyOrderedTo getFromTarget(Long id) {
		if (id == null) {
			return null;
		}
		for (One2ManyOrderedTo one2ManyOrderedTo : this.target) {
			if (id.equals(one2ManyOrderedTo.getId())) {
				return one2ManyOrderedTo;
			}
		}
		return null;
	}
	/**
	 * @return target (List<One2ManyOrderedTo>) 
	 */
	public List<One2ManyOrderedTo> getTarget() {
		return Collections.unmodifiableList(this.target);
	}

	/**
	 * Implements adding single element to a collection
	 */
	public boolean addToTarget(One2ManyOrderedTo element) {
		if (element == null) {
			return false;
		}
		if (this.target.contains(element)) {
			return false;
		}
		this.target.add(element);

		validation.validate();
		return true;
	}

	/**
	 * Implements removal of a single element from feature 
	 * 
	 * @param element 
	 */
	public boolean removeFromTarget(One2ManyOrderedTo element) {
		if (element == null) {
			return false;
		}
		if (this.target.remove(element)) {

			validation.validate();
			return true;
		}
		return false;
	}

	/**
	 * Implements adding single element to an ordered collection at a specified
	 * location.
	 */
	public void addToTarget(int index, One2ManyOrderedTo element) {
		if (element == null) {
			return;
		}
		this.target.add(index, element);

		validation.validate();
	}

	/**
	 * Removes the element at the specified position in {@link target}.
	 * Shifts any subsequent elements to the left (subtracts one from their
	 * indices). Returns the element that was removed from the list. 
	 * 
	 * @param index
	 *        the index of the element to remove. 
	 * @return the element previously at the specified position.
	 * @throws IndexOutOfBoundsException
	 *         if the index is out of range (index < 0 || index >= size()).
	 */
	public One2ManyOrderedTo removeFromTarget(int index) {
		One2ManyOrderedTo result;
		result = this.target.remove(index);

		validation.validate();
		return result;
	}

	/**
	 * Replaces the element at the specified position in
	 * {@link target} with the specified element.
	 * 
	 * @param index
	 *        index of element to replace.
	 * @param element
	 *        element to be stored at the specified position. 
	 * @return the element previously at the specified position.
	 * @throws IndexOutOfBoundsException
	 *         if the index is out of range (index < 0 || index >= size()).
	 */
	public One2ManyOrderedTo setTarget(int index, One2ManyOrderedTo element) {
		One2ManyOrderedTo result;
		validation.setActive(false);
		result = removeFromTarget(index);
		addToTarget(index, element);
		validation.setActive(true);
		validation.validate();
		return result;
	}

	/**
	 * This operation should NOT be used by clients.  It implements the correct
	 * addition of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalAddTotarget(One2ManyOrderedTo element) {
		this.target.add(element);
	}

	/**
	 * This operation should NOT be used by clients. It implements the correct
	 * removal of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalRemoveFromtarget(One2ManyOrderedTo element) {
		this.target.remove(element);
	}

	/**
	 *  one2ManyFrom: Verify that the name of the role of the many end of a one-to-many association may be
	the same as the class name.
	 */
	private Set<One2ManyFrom> one2ManyFrom = new HashSet<One2ManyFrom>();

	/**
	 * @param id
	 *        id of the collection element to return
	 *
	 * @return one2ManyFrom (One2ManyFrom)
	 *         with the given id.
	 */
	public One2ManyFrom getFromOne2ManyFrom(Long id) {
		if (id == null) {
			return null;
		}
		for (One2ManyFrom one2ManyFrom : this.one2ManyFrom) {
			if (id.equals(one2ManyFrom.getId())) {
				return one2ManyFrom;
			}
		}
		return null;
	}
	/**
	 * @return one2ManyFrom (Set<One2ManyFrom>) 
	 */
	public Set<One2ManyFrom> getOne2ManyFrom() {
		return Collections.unmodifiableSet(this.one2ManyFrom);
	}

	/**
	 * Implements adding single element to a collection
	 */
	public boolean addToOne2ManyFrom(One2ManyFrom element) {
		if (element == null) {
			return false;
		}
		if (this.one2ManyFrom.contains(element)) {
			return false;
		}
		this.one2ManyFrom.add(element);

		validation.validate();
		return true;
	}

	/**
	 * Implements removal of a single element from feature 
	 * 
	 * @param element 
	 */
	public boolean removeFromOne2ManyFrom(One2ManyFrom element) {
		if (element == null) {
			return false;
		}
		if (this.one2ManyFrom.remove(element)) {

			validation.validate();
			return true;
		}
		return false;
	}

	/**
	 * This operation should NOT be used by clients.  It implements the correct
	 * addition of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalAddToone2ManyFrom(One2ManyFrom element) {
		this.one2ManyFrom.add(element);
	}

	/**
	 * This operation should NOT be used by clients. It implements the correct
	 * removal of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalRemoveFromone2ManyFrom(One2ManyFrom element) {
		this.one2ManyFrom.remove(element);
	}

	/**
	 *  targetBiDirectional: 
	 */
	private Set<One2ManyOrderedTo> targetBiDirectional = new HashSet<One2ManyOrderedTo>();

	/**
	 * @param id
	 *        id of the collection element to return
	 *
	 * @return targetBiDirectional (One2ManyOrderedTo)
	 *         with the given id.
	 */
	public One2ManyOrderedTo getFromTargetBiDirectional(Long id) {
		if (id == null) {
			return null;
		}
		for (One2ManyOrderedTo one2ManyOrderedTo : this.targetBiDirectional) {
			if (id.equals(one2ManyOrderedTo.getId())) {
				return one2ManyOrderedTo;
			}
		}
		return null;
	}
	/**
	 * @return targetBiDirectional (Set<One2ManyOrderedTo>) 
	 */
	public Set<One2ManyOrderedTo> getTargetBiDirectional() {
		return Collections.unmodifiableSet(this.targetBiDirectional);
	}

	/**
	 * Implements adding single element to a collection
	 */
	public boolean addToTargetBiDirectional(One2ManyOrderedTo element) {
		if (element == null) {
			return false;
		}
		if (this.targetBiDirectional.contains(element)) {
			return false;
		}
		this.targetBiDirectional.add(element);

		if (element.getSource() != null) {
			element.getSource()
					.z_internalRemoveFromtargetBiDirectional(element);
		}
		element.z_internalAddTosource((One2ManyFrom) ((One2ManyFrom) this));

		validation.validate();
		return true;
	}

	/**
	 * Implements removal of a single element from feature 
	 * 
	 * @param element 
	 */
	public boolean removeFromTargetBiDirectional(One2ManyOrderedTo element) {
		if (element == null) {
			return false;
		}
		if (this.targetBiDirectional.remove(element)) {
			element
					.z_internalRemoveFromsource((One2ManyFrom) ((One2ManyFrom) this));

			validation.validate();
			return true;
		}
		return false;
	}

	/**
	 * This operation should NOT be used by clients.  It implements the correct
	 * addition of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalAddTotargetBiDirectional(One2ManyOrderedTo element) {
		this.targetBiDirectional.add(element);
	}

	/**
	 * This operation should NOT be used by clients. It implements the correct
	 * removal of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalRemoveFromtargetBiDirectional(
			One2ManyOrderedTo element) {
		this.targetBiDirectional.remove(element);
	}

	private void addValidators() {

		validation.addValidator(new NotNullValidator(One2ManyFrom.class,
				"property"));

	}

	/**
	 * Default no-argument constructor for One2ManyFromImplBase 
	 */
	protected One2ManyFromImplBase() {

		addValidators();
	}

	/**
	 * Minimal constructor for One2ManyFromImplBase
	 *
	 * @param property (String) 
	 */
	public One2ManyFromImplBase(String property) {

		this.property = property;
		addValidators();
		validation.validate();
	}

	/**
	 * @return property (String) 
	 */
	public String getProperty() {
		return this.property;
	}

	/**
	 * @param property (String) 
	 */
	public void setProperty(final String property) {
		this.property = property;
		validation.validate();
	}

	/**
	 * Activate/deactivate validation for this business class.
	 * When set to active the validation will immediately be executed.
	 * 
	 * @param value (boolean) 
	 */
	public void activateValidation(boolean value) {

		this.validation.setActive(value);
		if (value) {
			validation.validate();
		}
	}

}
