
/**
 * DO NOT MODIFY THIS FILE, CHANGES WILL BE AUTOMATICALLY OVERWRITTEN! 
 *
 * Generated by Mod4j. 
 *     Time             : Fri Jun 10 13:47:08 CEST 2011
 *     Application model: Order
 *     Generator        : Mod4j BusinessDomainDsl generator: NewJavaBean.xpt
 */

package org.company.webshop.domain;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.company.webshop.domain.Customer;
import org.company.webshop.domain.Order;
import org.company.webshop.domain.OrderLine;
import org.company.webshop.domain.businessrules.OrderDateBeforeDeliveryDate;
import org.joda.time.DateTime;
import org.mod4j.runtime.validation.BusinessRuleValidationSupport;
import org.mod4j.runtime.validation.MaxValueValidator;
import org.mod4j.runtime.validation.MinValueValidator;
import org.mod4j.runtime.validation.NotNullValidator;

/**
 * An Order represents the agreement between a Customer and the WebShop about one or more purchased Records.
 *
 * @author Generated by Mod4j BusinessDomain DSL
 */
@SuppressWarnings("serial")
public abstract class OrderImplBase implements java.io.Serializable {

	/**
	 * validation : Responsible for validating attribute constraints and businessrules for this business class.
	 * 
	 */
	protected BusinessRuleValidationSupport validation = new BusinessRuleValidationSupport(
			this);

	/**
	 *  id: The identifier of this object.
	 */
	private Long id;

	/**
	 *
	 * @return id (Long) The identifier of this object.
	 */
	public Long getId() {
		return this.id;
	}

	/**
	 * version: The version of this object 
	 */
	private int version = -1;

	/**
	 * @return version (Integer) The version of this object.
	 */
	public Integer getVersion() {
		return this.version;
	}

	/**
	 * toString method for OrderImplBase
	 */
	@Override
	public String toString() {
		StringBuffer result = new StringBuffer();
		result.append("org.company.webshop.domain.Order[");
		result.append("id=");
		result.append(getId());
		result.append(",");
		result.append("version=");
		result.append(getVersion());

		result.append(",");
		result.append("orderNumber=");
		result.append(orderNumber);

		result.append(",");
		result.append("orderDate=");
		result.append(orderDate);

		result.append(",");
		result.append("deliveryDateTime=");
		result.append(deliveryDateTime);

		result.append(",");
		result.append("discountPercentage=");
		result.append(discountPercentage);

		result.append("]");
		return result.toString();
	}

	/**
	 *  orderNumber: A number to identify the Order
	 */
	protected String orderNumber;

	/**
	 *  orderDate: The date on which the order has been placed
	 */
	protected DateTime orderDate = new DateTime("2009-01-01");

	/**
	 *  deliveryDateTime: 
	 */
	protected DateTime deliveryDateTime;

	/**
	 *  discountPercentage: 
	 */
	protected Integer discountPercentage;

	public static final Integer DISCOUNTPERCENTAGE_MINVALUE = 1;

	public static final Integer DISCOUNTPERCENTAGE_MAXVALUE = 100;

	/**
	 *  orderLines: One 2 Many unidirectional: An order consists of an ordered list of orderLines.
	This is a typical composite relation: An orderLine must be attached to an existing order. 
	When an order is deleted, also a cascading delete of all the orderLines attached to it must be performed.
	 */
	private List<OrderLine> orderLines = new ArrayList<OrderLine>();

	/**
	 * @param id
	 *        id of the collection element to return
	 *
	 * @return orderLines (OrderLine)
	 *         with the given id.
	 */
	public OrderLine getFromOrderLines(Long id) {
		if (id == null) {
			return null;
		}
		for (OrderLine orderLine : this.orderLines) {
			if (id.equals(orderLine.getId())) {
				return orderLine;
			}
		}
		return null;
	}
	/**
	 * @return orderLines (List<OrderLine>) 
	 */
	public List<OrderLine> getOrderLines() {
		return Collections.unmodifiableList(this.orderLines);
	}

	/**
	 * Implements adding single element to a collection
	 */
	public boolean addToOrderLines(OrderLine element) {
		if (element == null) {
			return false;
		}
		if (this.orderLines.contains(element)) {
			return false;
		}
		this.orderLines.add(element);

		validation.validate();
		return true;
	}

	/**
	 * Implements removal of a single element from feature 
	 * 
	 * @param element 
	 */
	public boolean removeFromOrderLines(OrderLine element) {
		if (element == null) {
			return false;
		}
		if (this.orderLines.remove(element)) {

			validation.validate();
			return true;
		}
		return false;
	}

	/**
	 * Implements adding single element to an ordered collection at a specified
	 * location.
	 */
	public void addToOrderLines(int index, OrderLine element) {
		if (element == null) {
			return;
		}
		this.orderLines.add(index, element);

		validation.validate();
	}

	/**
	 * Removes the element at the specified position in {@link orderLines}.
	 * Shifts any subsequent elements to the left (subtracts one from their
	 * indices). Returns the element that was removed from the list. 
	 * 
	 * @param index
	 *        the index of the element to remove. 
	 * @return the element previously at the specified position.
	 * @throws IndexOutOfBoundsException
	 *         if the index is out of range (index < 0 || index >= size()).
	 */
	public OrderLine removeFromOrderLines(int index) {
		OrderLine result;
		result = this.orderLines.remove(index);

		validation.validate();
		return result;
	}

	/**
	 * Replaces the element at the specified position in
	 * {@link orderLines} with the specified element.
	 * 
	 * @param index
	 *        index of element to replace.
	 * @param element
	 *        element to be stored at the specified position. 
	 * @return the element previously at the specified position.
	 * @throws IndexOutOfBoundsException
	 *         if the index is out of range (index < 0 || index >= size()).
	 */
	public OrderLine setOrderLines(int index, OrderLine element) {
		OrderLine result;
		validation.setActive(false);
		result = removeFromOrderLines(index);
		addToOrderLines(index, element);
		validation.setActive(true);
		validation.validate();
		return result;
	}

	/**
	 * This operation should NOT be used by clients.  It implements the correct
	 * addition of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalAddToorderLines(OrderLine element) {
		this.orderLines.add(element);
	}

	/**
	 * This operation should NOT be used by clients. It implements the correct
	 * removal of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalRemoveFromorderLines(OrderLine element) {
		this.orderLines.remove(element);
	}

	private Customer customer;

	/**
	 * Implements the getter of association end 
	 * 
	 * @param element 
	 */
	public Customer getCustomer() {
		return this.customer;
	}

	/**
	 * Implements the setter of association end 
	 * 
	 * @param element 
	 */
	public void setCustomer(Customer element) {
		if (this.customer != element) {
			if (this.customer != null) {
				this.customer
						.z_internalRemoveFromorders((Order) ((Order) this));
			}
			this.customer = element;
			if (element != null) {
				element.z_internalAddToorders((Order) ((Order) this));
			}
		}
		validation.validate();
	}

	/**
	 * Should NOT be used by clients! Implements the correct setting of the link
	 * for + owner when a single element is added to it.
	 * 
	 * @param element 
	 */
	public void z_internalAddTocustomer(Customer element) {
		this.customer = element;
	}

	/**
	 * Should NOT be used by clients! Implements the correct setting of the link for + owner  
	 *                  when a single element is removed to it.
	 * 
	 * @param element 
	 */
	public void z_internalRemoveFromcustomer(Customer element) {
		this.customer = null;
	}

	private void addValidators() {

		validation
				.addValidator(new NotNullValidator(Order.class, "orderNumber"));

		validation.addValidator(new MinValueValidator(Order.class,
				"discountPercentage", DISCOUNTPERCENTAGE_MINVALUE));
		validation.addValidator(new MaxValueValidator(Order.class,
				"discountPercentage", DISCOUNTPERCENTAGE_MAXVALUE));
		validation.addValidator(new OrderDateBeforeDeliveryDate());

	}

	/**
	 * Default no-argument constructor for OrderImplBase 
	 */
	protected OrderImplBase() {

		addValidators();
	}

	/**
	 * Minimal constructor for OrderImplBase
	 *
	 * @param orderNumber (String) A number to identify the Order
	 */
	public OrderImplBase(String orderNumber) {

		this.orderNumber = orderNumber;
		addValidators();
		validation.validate();
	}

	/**
	 * @return orderNumber (String) A number to identify the Order
	 */
	public String getOrderNumber() {
		return this.orderNumber;
	}

	/**
	 * @return orderDate (DateTime) The date on which the order has been placed
	 */
	public DateTime getOrderDate() {
		return this.orderDate;
	}

	/**
	 * @return deliveryDateTime (DateTime) 
	 */
	public DateTime getDeliveryDateTime() {
		return this.deliveryDateTime;
	}

	/**
	 * @return discountPercentage (Integer) 
	 */
	public Integer getDiscountPercentage() {
		return this.discountPercentage;
	}

	/**
	 * @param orderNumber (String) A number to identify the Order
	 */
	public void setOrderNumber(final String orderNumber) {
		this.orderNumber = orderNumber;
		validation.validate();
	}

	/**
	 * @param orderDate (DateTime) The date on which the order has been placed
	 */
	public void setOrderDate(final DateTime orderDate) {
		this.orderDate = orderDate;
		validation.validate();
	}

	/**
	 * @param deliveryDateTime (DateTime) 
	 */
	public void setDeliveryDateTime(final DateTime deliveryDateTime) {
		this.deliveryDateTime = deliveryDateTime;
		validation.validate();
	}

	/**
	 * @param discountPercentage (Integer) 
	 */
	public void setDiscountPercentage(final Integer discountPercentage) {
		this.discountPercentage = discountPercentage;
		validation.validate();
	}

	/**
	 * @return totalAmount (Float) The total amount of the Order. Its value is derived from the summation of the OrderLine amounts
	 */
	abstract public Float getTotalAmount();

	/**
	 * Activate/deactivate validation for this business class.
	 * When set to active the validation will immediately be executed.
	 * 
	 * @param value (boolean) 
	 */
	public void activateValidation(boolean value) {

		this.validation.setActive(value);
		if (value) {
			validation.validate();
		}
	}

}
