
/**
 * DO NOT MODIFY THIS FILE, CHANGES WILL BE AUTOMATICALLY OVERWRITTEN! 
 *
 * Generated by Mod4j. 
 *     Time             : Fri Jun 10 13:47:07 CEST 2011
 *     Application model: Person
 *     Generator        : Mod4j BusinessDomainDsl generator: NewJavaBean.xpt
 */

package org.company.webshop.domain;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import org.company.webshop.domain.Artist;
import org.company.webshop.domain.Person;
import org.company.webshop.domain.Relation;
import org.joda.time.DateTime;
import org.mod4j.runtime.validation.BusinessRuleValidationSupport;
import org.mod4j.runtime.validation.MaxValueValidator;
import org.mod4j.runtime.validation.MinValueValidator;
import org.mod4j.runtime.validation.NotNullValidator;

/**
 * A Person represents a legal person.
 *
 * @author Generated by Mod4j BusinessDomain DSL
 */
@SuppressWarnings("serial")
public abstract class PersonImplBase implements java.io.Serializable {

	/**
	 * validation : Responsible for validating attribute constraints and businessrules for this business class.
	 * 
	 */
	protected BusinessRuleValidationSupport validation = new BusinessRuleValidationSupport(
			this);

	/**
	 *  id: The identifier of this object.
	 */
	private Long id;

	/**
	 *
	 * @return id (Long) The identifier of this object.
	 */
	public Long getId() {
		return this.id;
	}

	/**
	 * version: The version of this object 
	 */
	private int version = -1;

	/**
	 * @return version (Integer) The version of this object.
	 */
	public Integer getVersion() {
		return this.version;
	}

	/**
	 * toString method for PersonImplBase
	 */
	@Override
	public String toString() {
		StringBuffer result = new StringBuffer();
		result.append("org.company.webshop.domain.Person[");
		result.append("id=");
		result.append(getId());
		result.append(",");
		result.append("version=");
		result.append(getVersion());

		result.append(",");
		result.append("firstName=");
		result.append(firstName);

		result.append(",");
		result.append("lastName=");
		result.append(lastName);

		result.append(",");
		result.append("birthDate=");
		result.append(birthDate);

		result.append(",");
		result.append("numberOfEars=");
		result.append(numberOfEars);

		result.append(",");
		result.append("sexe=");
		result.append(sexe);

		result.append("]");
		return result.toString();
	}

	/**
	 *  firstName: First name of the person.
	 */
	protected String firstName;

	/**
	 *  lastName: Last name of the person.
	 */
	protected String lastName;

	/**
	 *  birthDate: 
	 */
	protected DateTime birthDate;

	/**
	 *  numberOfEars: Number of ears (we allow Vulcans in this system).
	 */
	protected Integer numberOfEars = 2;

	public static final Integer NUMBEROFEARS_MINVALUE = 0;

	public static final Integer NUMBEROFEARS_MAXVALUE = 4;

	/**
	 *  sexe: Gender
	 */
	protected SexeEnum sexe = SexeEnum.MALE;

	/**
	 *  relationsFrom: 
	 */
	private Set<Relation> relationsFrom = new HashSet<Relation>();

	/**
	 * @param id
	 *        id of the collection element to return
	 *
	 * @return relationsFrom (Relation)
	 *         with the given id.
	 */
	public Relation getFromRelationsFrom(Long id) {
		if (id == null) {
			return null;
		}
		for (Relation relation : this.relationsFrom) {
			if (id.equals(relation.getId())) {
				return relation;
			}
		}
		return null;
	}
	/**
	 * @return relationsFrom (Set<Relation>) 
	 */
	public Set<Relation> getRelationsFrom() {
		return Collections.unmodifiableSet(this.relationsFrom);
	}

	/**
	 * Implements adding single element to a collection
	 */
	public boolean addToRelationsFrom(Relation element) {
		if (element == null) {
			return false;
		}
		if (this.relationsFrom.contains(element)) {
			return false;
		}
		this.relationsFrom.add(element);

		if (element.getPersonFrom() != null) {
			element.getPersonFrom().z_internalRemoveFromrelationsFrom(element);
		}
		element.z_internalAddTopersonFrom((Person) ((Person) this));

		validation.validate();
		return true;
	}

	/**
	 * Implements removal of a single element from feature 
	 * 
	 * @param element 
	 */
	public boolean removeFromRelationsFrom(Relation element) {
		if (element == null) {
			return false;
		}
		if (this.relationsFrom.remove(element)) {
			element.z_internalRemoveFrompersonFrom((Person) ((Person) this));

			validation.validate();
			return true;
		}
		return false;
	}

	/**
	 * This operation should NOT be used by clients.  It implements the correct
	 * addition of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalAddTorelationsFrom(Relation element) {
		this.relationsFrom.add(element);
	}

	/**
	 * This operation should NOT be used by clients. It implements the correct
	 * removal of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalRemoveFromrelationsFrom(Relation element) {
		this.relationsFrom.remove(element);
	}

	/**
	 *  relatedTo: Tests
	 */
	private Set<Artist> relatedTo = new HashSet<Artist>();

	/**
	 * @param id
	 *        id of the collection element to return
	 *
	 * @return relatedTo (Artist)
	 *         with the given id.
	 */
	public Artist getFromRelatedTo(Long id) {
		if (id == null) {
			return null;
		}
		for (Artist artist : this.relatedTo) {
			if (id.equals(artist.getId())) {
				return artist;
			}
		}
		return null;
	}
	/**
	 * @return relatedTo (Set<Artist>) 
	 */
	public Set<Artist> getRelatedTo() {
		return Collections.unmodifiableSet(this.relatedTo);
	}

	/**
	 * Implements adding single element to a collection
	 */
	public boolean addToRelatedTo(Artist element) {
		if (element == null) {
			return false;
		}
		if (this.relatedTo.contains(element)) {
			return false;
		}
		this.relatedTo.add(element);

		validation.validate();
		return true;
	}

	/**
	 * Implements removal of a single element from feature 
	 * 
	 * @param element 
	 */
	public boolean removeFromRelatedTo(Artist element) {
		if (element == null) {
			return false;
		}
		if (this.relatedTo.remove(element)) {

			validation.validate();
			return true;
		}
		return false;
	}

	/**
	 * This operation should NOT be used by clients.  It implements the correct
	 * addition of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalAddTorelatedTo(Artist element) {
		this.relatedTo.add(element);
	}

	/**
	 * This operation should NOT be used by clients. It implements the correct
	 * removal of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalRemoveFromrelatedTo(Artist element) {
		this.relatedTo.remove(element);
	}

	/**
	 *  relationsTo: 
	 */
	private Set<Relation> relationsTo = new HashSet<Relation>();

	/**
	 * @param id
	 *        id of the collection element to return
	 *
	 * @return relationsTo (Relation)
	 *         with the given id.
	 */
	public Relation getFromRelationsTo(Long id) {
		if (id == null) {
			return null;
		}
		for (Relation relation : this.relationsTo) {
			if (id.equals(relation.getId())) {
				return relation;
			}
		}
		return null;
	}
	/**
	 * @return relationsTo (Set<Relation>) 
	 */
	public Set<Relation> getRelationsTo() {
		return Collections.unmodifiableSet(this.relationsTo);
	}

	/**
	 * Implements adding single element to a collection
	 */
	public boolean addToRelationsTo(Relation element) {
		if (element == null) {
			return false;
		}
		if (this.relationsTo.contains(element)) {
			return false;
		}
		this.relationsTo.add(element);

		if (element.getPersonTo() != null) {
			element.getPersonTo().z_internalRemoveFromrelationsTo(element);
		}
		element.z_internalAddTopersonTo((Person) ((Person) this));

		validation.validate();
		return true;
	}

	/**
	 * Implements removal of a single element from feature 
	 * 
	 * @param element 
	 */
	public boolean removeFromRelationsTo(Relation element) {
		if (element == null) {
			return false;
		}
		if (this.relationsTo.remove(element)) {
			element.z_internalRemoveFrompersonTo((Person) ((Person) this));

			validation.validate();
			return true;
		}
		return false;
	}

	/**
	 * This operation should NOT be used by clients.  It implements the correct
	 * addition of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalAddTorelationsTo(Relation element) {
		this.relationsTo.add(element);
	}

	/**
	 * This operation should NOT be used by clients. It implements the correct
	 * removal of an element in an association.
	 * 
	 * @param element 
	 */
	public void z_internalRemoveFromrelationsTo(Relation element) {
		this.relationsTo.remove(element);
	}

	private void addValidators() {

		validation
				.addValidator(new NotNullValidator(Person.class, "firstName"));

		validation.addValidator(new NotNullValidator(Person.class, "lastName"));

		validation
				.addValidator(new NotNullValidator(Person.class, "birthDate"));

		validation.addValidator(new NotNullValidator(Person.class,
				"numberOfEars"));
		validation.addValidator(new MinValueValidator(Person.class,
				"numberOfEars", NUMBEROFEARS_MINVALUE));
		validation.addValidator(new MaxValueValidator(Person.class,
				"numberOfEars", NUMBEROFEARS_MAXVALUE));

	}

	/**
	 * Default no-argument constructor for PersonImplBase 
	 */
	protected PersonImplBase() {

		addValidators();
	}

	/**
	 * Minimal constructor for PersonImplBase
	 *
	 * @param firstName (String) First name of the person.
	 * @param lastName (String) Last name of the person.
	 * @param birthDate (DateTime) 
	 */
	public PersonImplBase(String firstName, String lastName, DateTime birthDate) {

		this.firstName = firstName;
		this.lastName = lastName;
		this.birthDate = birthDate;
		addValidators();
		validation.validate();
	}

	/**
	 * @return firstName (String) First name of the person.
	 */
	public String getFirstName() {
		return this.firstName;
	}

	/**
	 * @return lastName (String) Last name of the person.
	 */
	public String getLastName() {
		return this.lastName;
	}

	/**
	 * @return birthDate (DateTime) 
	 */
	public DateTime getBirthDate() {
		return this.birthDate;
	}

	/**
	 * @return numberOfEars (Integer) Number of ears (we allow Vulcans in this system).
	 */
	public Integer getNumberOfEars() {
		return this.numberOfEars;
	}

	/**
	 * @return sexe (SexeEnum) Gender
	 */
	public SexeEnum getSexe() {
		return this.sexe;
	}

	/**
	 * @param firstName (String) First name of the person.
	 */
	public void setFirstName(final String firstName) {
		this.firstName = firstName;
		validation.validate();
	}

	/**
	 * @param lastName (String) Last name of the person.
	 */
	public void setLastName(final String lastName) {
		this.lastName = lastName;
		validation.validate();
	}

	/**
	 * @param birthDate (DateTime) 
	 */
	public void setBirthDate(final DateTime birthDate) {
		this.birthDate = birthDate;
		validation.validate();
	}

	/**
	 * @param numberOfEars (Integer) Number of ears (we allow Vulcans in this system).
	 */
	public void setNumberOfEars(final Integer numberOfEars) {
		this.numberOfEars = numberOfEars;
		validation.validate();
	}

	/**
	 * @param sexe (SexeEnum) Gender
	 */
	public void setSexe(final SexeEnum sexe) {
		this.sexe = sexe;
		validation.validate();
	}

	/**
	 * @return age (Integer) The age of this person in years, derived from birthDate
	 */
	abstract public Integer getAge();

	/**
	 * Activate/deactivate validation for this business class.
	 * When set to active the validation will immediately be executed.
	 * 
	 * @param value (boolean) 
	 */
	public void activateValidation(boolean value) {

		this.validation.setActive(value);
		if (value) {
			validation.validate();
		}
	}

}
