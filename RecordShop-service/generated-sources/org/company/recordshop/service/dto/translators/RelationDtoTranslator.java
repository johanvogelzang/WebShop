
/**
 * DO NOT MODIFY THIS FILE, CHANGES WILL BE AUTOMATICALLY OVERWRITTEN! 
 *
 * Generated by Mod4j. 
 *     Time             : Fri Jun 10 13:47:12 CEST 2011
 *     Application model: RelationDto
 *     Generator        : Mod4j DatacontractDsl generator: Translators.xpt
 */

package org.company.recordshop.service.dto.translators;

import java.util.HashMap;
import java.util.Map;
import java.util.HashSet;
import java.util.Set;
import org.springframework.util.Assert;
import org.mod4j.runtime.exception.ConcurrentUpdateException;
import org.company.recordshop.domain.Relation;
import org.company.recordshop.domain.RelationExample;
import org.company.recordshop.service.dto.RelationDto;
import org.company.recordshop.domain.Person;
import org.company.recordshop.service.dto.PersonDto;
import org.company.recordshop.domain.Person;
import org.company.recordshop.service.dto.PersonDto;

import org.company.recordshop.data.PersonDao;

import org.company.recordshop.data.PersonDao;

/**
 * Translator for translating Relation domain objects from- and to RelationDto data transfer objects. 
 *
 * @author generated by Mod4j
 */
public class RelationDtoTranslator {

	protected PersonDtoTranslator personDtoTranslator;

	/**
	 * @param object
	 *            The personDtoTranslator to set.
	 */
	public void setPersonDtoTranslator(PersonDtoTranslator object) {
		this.personDtoTranslator = object;
	}

	/** 
	 * @return The personDtoTranslator to get.
	 *
	 */
	public PersonDtoTranslator getPersonDtoTranslator() {
		return this.personDtoTranslator;
	}

	protected PersonDao personDao;

	/**
	 * @param object
	 *            The personDao to set.
	 */
	public void setPersonDao(PersonDao object) {
		this.personDao = object;
	}

	/** 
	 * @return The personDao to get.
	 *
	 */
	public PersonDao getPersonDao() {
		return this.personDao;
	}

	/**
	
	 * Translates a RelationDto dto object into a Relation domain object.
	 * A new domain object will be created passed to the {@link #fromDto(RelationDto, Relation)}.
	.
	 *
	 * @param source The {@link RelationDto} object to translate, may not be {@code null}.
	 * @return {@link Relation}, the resulting domain object.
	 */
	public Relation fromDto(final RelationDto source) {
		return fromDto(source, new HashMap<Object, Object>());
	}

	Relation fromDto(final RelationDto source,
			final Map<Object, Object> translated) {

		Assert.notNull(source, "argument [source] may not be null");
		Assert.isNull(source.getId(),
				"Can not translate a dto with existing id to a new domain object. Dto: "
						+ source);
		Relation target = new Relation(source.getName()

		);
		return fromDto(source, target, translated);

	}

	/**
	 * Translates a RelationDto dto object into a Relation domain object. All properties in the dto will be mapped to the 
	 * corresponding property in the <code>target</code> domain object. 
	 *
	 * @param source The {@link RelationDto} object to translate, may not be {@code null}.
	 * @param target The {@link Relation} object translated from source, may not be {@code null}.
	 * @return {@link Relation}, the resulting domain object.
	 */
	public Relation fromDto(final RelationDto source, final Relation target) {
		return fromDto(source, target, new HashMap<Object, Object>());
	}

	Relation fromDto(final RelationDto source, final Relation target,
			final Map<Object, Object> translated) {

		if (translated.containsKey((source))) {
			return (Relation) translated.get(source);
		}

		Assert.notNull(source, "argument [source] may not be null");
		Assert.notNull(target, "argument [target] may not be null");

		final boolean equals = (source.getId() == null)
				? target.getId() == null
				: source.getId().equals(target.getId());

		if (!equals) {
			throw new IllegalArgumentException(
					"Can not translate a dto to a domain object when the id of the dto differs from the id of the domain object.");
		}

		validateVersion(source, target);

		target.activateValidation(false);

		target.setName(source.getName());

		target.setSince(source.getSince());

		translated.put(source, target);

		/*
		 * Synchronize PersonTo association.
		 */

		if (source.getPersonTo() == null) {
			/* Delete associated object */
			target.setPersonTo(null);
		} else { // source.getPersonTo() != null ) {
			/* Add a new associated object */
			if (source.getPersonTo().getId() != null) {
				/* Add an existing object */
				Person original = personDao.retrieve(source.getPersonTo()
						.getId());
				Person updated = personDtoTranslator.fromDto(source
						.getPersonTo(), original, translated);
				target.setPersonTo(updated);
			} else {
				/* Add a new object */
				target.setPersonTo(personDtoTranslator.fromDto(source
						.getPersonTo(), translated));
			}
		}

		/*
		 * Synchronize PersonFrom association.
		 */

		if (source.getPersonFrom() == null) {
			/* Delete associated object */
			target.setPersonFrom(null);
		} else { // source.getPersonFrom() != null ) {
			/* Add a new associated object */
			if (source.getPersonFrom().getId() != null) {
				/* Add an existing object */
				Person original = personDao.retrieve(source.getPersonFrom()
						.getId());
				Person updated = personDtoTranslator.fromDto(source
						.getPersonFrom(), original, translated);
				target.setPersonFrom(updated);
			} else {
				/* Add a new object */
				target.setPersonFrom(personDtoTranslator.fromDto(source
						.getPersonFrom(), translated));
			}
		}

		target.activateValidation(true);

		return target;
	}

	/**
	 * Translates a Relation domain object into a RelationDto dto object. Properties and associations of the domain object
	 * will be mapped to the corresponding properties and associations in the dto object.
	 * To prevent looping while translating biderectional or circulair associations translated objects will be added to the 'translated' register.    
	 *
	 * @param source The {@link Relation} object to translate.
	 *
	 * @return RelationDto The {@link RelationDto} object translated from source.
	 */
	public RelationDto toDto(final Relation source) {
		return toDto(source, new HashMap<Object, Object>());
	}

	RelationDto toDto(final Relation source,
			final Map<Object, Object> translated) {
		if (translated.containsKey((source))) {
			return (RelationDto) translated.get(source);
		}
		Assert.notNull(source, "argument [source] may not be null");
		RelationDto result = new RelationDto(source.getId(), source
				.getVersion());
		result.setName(source.getName());
		result.setSince(source.getSince());

		translated.put(source, result);

		if (source.getPersonTo() != null) {
			result.setPersonTo(personDtoTranslator.toDto(source.getPersonTo(),
					translated));
		}

		if (source.getPersonFrom() != null) {
			result.setPersonFrom(personDtoTranslator.toDto(source
					.getPersonFrom(), translated));
		}

		return result;
	}

	/**
	 * Translates a RelationDto dto object into a RelationExample Example domain object. 
	 * All properties in the dto will be mapped to the corresponding property in the <code>target</code> domain object. 
	 * Association references in the dto will not be translated into the <code>target</code> domain object.
	 *
	 * @param source The {@link RelationDto} object to translate.
	 *
	 * @return {@link RelationExample}, the resulting businessclass object.
	 */
	public RelationExample exampleFromDto(final RelationDto source) {
		Assert.notNull(source, "argument [source] may not be null");
		RelationExample result = new RelationExample();

		if (source.getName() != null) {
			result.setName(source.getName());
		}
		if (source.getSince() != null) {
			result.setSince(source.getSince());
		}

		return result;
	}

	/**
	 * Validate that the version of the DTO and the business object are valid.
	 * The DTO may only have a version if the domain object also has a version.
	 * When they both have a version and the DTO version is less, another user
	 * has updated the domain object in the meantime, if it is equal, all is
	 * well. If it is more, an unexpected situation occurs: the DTOs is more new
	 * then the domain object: this is not possible.
	 * 
	 * @param source
	 *            The DTO.
	 * @param target
	 *            The domain object target.
	 */
	private void validateVersion(final RelationDto source, final Relation target) {
		final Integer sourceVersion = source.getVersion();
		final Integer targetVersion = target.getVersion();

		// FIXME the DTO translator should not know that -1 is the default unpersisted value!
		final boolean equals = (sourceVersion == null)
				? targetVersion == -1
				: sourceVersion.equals(targetVersion);

		if (!equals) {
			throw new ConcurrentUpdateException(
					"Versions of source and target do not match for dto "
							+ source + ", source is " + sourceVersion
							+ ", target is " + targetVersion + ".");
		}
	}
}
