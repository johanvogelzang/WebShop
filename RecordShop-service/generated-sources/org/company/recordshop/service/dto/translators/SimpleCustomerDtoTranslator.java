
/**
 * DO NOT MODIFY THIS FILE, CHANGES WILL BE AUTOMATICALLY OVERWRITTEN! 
 *
 * Generated by Mod4j. 
 *     Time             : Fri Jun 10 13:47:12 CEST 2011
 *     Application model: SimpleCustomerDto
 *     Generator        : Mod4j DatacontractDsl generator: Translators.xpt
 */

package org.company.recordshop.service.dto.translators;

import java.util.HashMap;
import java.util.Map;
import java.util.HashSet;
import java.util.Set;
import org.springframework.util.Assert;
import org.mod4j.runtime.exception.ConcurrentUpdateException;
import org.company.recordshop.domain.Customer;
import org.company.recordshop.domain.CustomerExample;
import org.company.recordshop.service.dto.SimpleCustomerDto;
import org.company.recordshop.domain.Order;
import org.company.recordshop.service.dto.OrderNumberAndDateDto;
import org.company.recordshop.domain.Artist;
import org.company.recordshop.service.dto.ArtistDto;
import org.company.recordshop.domain.Artist;
import org.company.recordshop.service.dto.DisLikesDto;

import org.company.recordshop.data.OrderDao;

import org.company.recordshop.data.ArtistDao;

import org.company.recordshop.data.ArtistDao;

/**
 * Translator for translating Customer domain objects from- and to SimpleCustomerDto data transfer objects. 
 *
 * @author generated by Mod4j
 */
public class SimpleCustomerDtoTranslator {

	protected OrderNumberAndDateDtoTranslator orderNumberAndDateDtoTranslator;

	/**
	 * @param object
	 *            The orderNumberAndDateDtoTranslator to set.
	 */
	public void setOrderNumberAndDateDtoTranslator(
			OrderNumberAndDateDtoTranslator object) {
		this.orderNumberAndDateDtoTranslator = object;
	}

	/** 
	 * @return The orderNumberAndDateDtoTranslator to get.
	 *
	 */
	public OrderNumberAndDateDtoTranslator getOrderNumberAndDateDtoTranslator() {
		return this.orderNumberAndDateDtoTranslator;
	}

	protected ArtistDtoTranslator artistDtoTranslator;

	/**
	 * @param object
	 *            The artistDtoTranslator to set.
	 */
	public void setArtistDtoTranslator(ArtistDtoTranslator object) {
		this.artistDtoTranslator = object;
	}

	/** 
	 * @return The artistDtoTranslator to get.
	 *
	 */
	public ArtistDtoTranslator getArtistDtoTranslator() {
		return this.artistDtoTranslator;
	}

	protected DisLikesDtoTranslator disLikesDtoTranslator;

	/**
	 * @param object
	 *            The disLikesDtoTranslator to set.
	 */
	public void setDisLikesDtoTranslator(DisLikesDtoTranslator object) {
		this.disLikesDtoTranslator = object;
	}

	/** 
	 * @return The disLikesDtoTranslator to get.
	 *
	 */
	public DisLikesDtoTranslator getDisLikesDtoTranslator() {
		return this.disLikesDtoTranslator;
	}

	protected OrderDao orderDao;

	/**
	 * @param object
	 *            The orderDao to set.
	 */
	public void setOrderDao(OrderDao object) {
		this.orderDao = object;
	}

	/** 
	 * @return The orderDao to get.
	 *
	 */
	public OrderDao getOrderDao() {
		return this.orderDao;
	}

	protected ArtistDao artistDao;

	/**
	 * @param object
	 *            The artistDao to set.
	 */
	public void setArtistDao(ArtistDao object) {
		this.artistDao = object;
	}

	/** 
	 * @return The artistDao to get.
	 *
	 */
	public ArtistDao getArtistDao() {
		return this.artistDao;
	}

	private SexeEnumDtoTranslator sexeTranslator = new SexeEnumDtoTranslator();

	/**
	
	 * Translates a SimpleCustomerDto dto object into a Customer domain object.
	 * A new domain object will be created passed to the {@link #fromDto(SimpleCustomerDto, Customer)}.
	.
	 *
	 * @param source The {@link SimpleCustomerDto} object to translate, may not be {@code null}.
	 * @return {@link Customer}, the resulting domain object.
	 */
	public Customer fromDto(final SimpleCustomerDto source) {
		return fromDto(source, new HashMap<Object, Object>());
	}

	Customer fromDto(final SimpleCustomerDto source,
			final Map<Object, Object> translated) {

		Assert.notNull(source, "argument [source] may not be null");
		Assert.isNull(source.getId(),
				"Can not translate a dto with existing id to a new domain object. Dto: "
						+ source);
		Customer target = new Customer(source.getFirstName(), source
				.getLastName(), source.getBirthDate(), source.getCustomerNr()

		);
		return fromDto(source, target, translated);

	}

	/**
	 * Translates a SimpleCustomerDto dto object into a Customer domain object. All properties in the dto will be mapped to the 
	 * corresponding property in the <code>target</code> domain object. 
	 *
	 * @param source The {@link SimpleCustomerDto} object to translate, may not be {@code null}.
	 * @param target The {@link Customer} object translated from source, may not be {@code null}.
	 * @return {@link Customer}, the resulting domain object.
	 */
	public Customer fromDto(final SimpleCustomerDto source,
			final Customer target) {
		return fromDto(source, target, new HashMap<Object, Object>());
	}

	Customer fromDto(final SimpleCustomerDto source, final Customer target,
			final Map<Object, Object> translated) {

		if (translated.containsKey((source))) {
			return (Customer) translated.get(source);
		}

		Assert.notNull(source, "argument [source] may not be null");
		Assert.notNull(target, "argument [target] may not be null");

		final boolean equals = (source.getId() == null)
				? target.getId() == null
				: source.getId().equals(target.getId());

		if (!equals) {
			throw new IllegalArgumentException(
					"Can not translate a dto to a domain object when the id of the dto differs from the id of the domain object.");
		}

		validateVersion(source, target);

		target.activateValidation(false);

		target.setCustomerNr(source.getCustomerNr());

		target.setLastName(source.getLastName());

		target.setFirstName(source.getFirstName());

		target.setBlackListed(source.isBlackListed());

		target.setUsername(source.getUsername());

		target.setSexe(sexeTranslator.fromDto(source.getSexe()));

		target.setBirthDate(source.getBirthDate());

		translated.put(source, target);

		/*
		 * Synchronize Orders association.
		 */
		Set<Order> ordersToBeRemoved = new HashSet<Order>();
		/* Avoid changing the collection underneath an active iterator. */
		for (Order element : target.getOrders()) {
			if (source.getFromOrders(element.getId()) == null) {
				ordersToBeRemoved.add(element);
			}
		}
		/* Objects to be removed */
		for (Order element : ordersToBeRemoved) {
			target.removeFromOrders(element);
		}
		for (OrderNumberAndDateDto element : source.getOrders()) {
			if (element.getId() == null) {
				/* A new object to be added */
				target.addToOrders(orderNumberAndDateDtoTranslator.fromDto(
						element, translated));
			} else {

				/* An existing object to be updated */
				if (target.getFromOrders(element.getId()) == null) {
					// Element is not in target yet, read it from the store and add to target
					Order original = orderDao.retrieve(element.getId());
					Order updated = orderNumberAndDateDtoTranslator.fromDto(
							element, original, translated);
					target.addToOrders(updated);
				} else {
					// Element is in target already, use this object. No need to add to the collection
					orderNumberAndDateDtoTranslator.fromDto(element, target
							.getFromOrders(element.getId()), translated);
				}
			}
		}

		/*
		 * Synchronize Idols association.
		 */
		Set<Artist> idolsToBeRemoved = new HashSet<Artist>();
		/* Avoid changing the collection underneath an active iterator. */
		for (Artist element : target.getIdols()) {
			if (source.getFromIdols(element.getId()) == null) {
				idolsToBeRemoved.add(element);
			}
		}
		/* Objects to be removed */
		for (Artist element : idolsToBeRemoved) {
			target.removeFromIdols(element);
		}
		for (ArtistDto element : source.getIdols()) {
			if (element.getId() == null) {
				/* A new object to be added */
				target.addToIdols(artistDtoTranslator.fromDto(element,
						translated));
			} else {

				/* An existing object to be updated */
				if (target.getFromIdols(element.getId()) == null) {
					// Element is not in target yet, read it from the store and add to target
					Artist original = artistDao.retrieve(element.getId());
					Artist updated = artistDtoTranslator.fromDto(element,
							original, translated);
					target.addToIdols(updated);
				} else {
					// Element is in target already, use this object. No need to add to the collection
					artistDtoTranslator.fromDto(element, target
							.getFromIdols(element.getId()), translated);
				}
			}
		}

		/*
		 * Synchronize RelatedTo association.
		 */
		Set<Artist> relatedToToBeRemoved = new HashSet<Artist>();
		/* Avoid changing the collection underneath an active iterator. */
		for (Artist element : target.getRelatedTo()) {
			if (source.getFromRelatedTo(element.getId()) == null) {
				relatedToToBeRemoved.add(element);
			}
		}
		/* Objects to be removed */
		for (Artist element : relatedToToBeRemoved) {
			target.removeFromRelatedTo(element);
		}
		for (DisLikesDto element : source.getRelatedTo()) {
			if (element.getId() == null) {
				/* A new object to be added */
				target.addToRelatedTo(disLikesDtoTranslator.fromDto(element,
						translated));
			} else {

				/* An existing object to be updated */
				if (target.getFromRelatedTo(element.getId()) == null) {
					// Element is not in target yet, read it from the store and add to target
					Artist original = artistDao.retrieve(element.getId());
					Artist updated = disLikesDtoTranslator.fromDto(element,
							original, translated);
					target.addToRelatedTo(updated);
				} else {
					// Element is in target already, use this object. No need to add to the collection
					disLikesDtoTranslator.fromDto(element, target
							.getFromRelatedTo(element.getId()), translated);
				}
			}
		}

		target.activateValidation(true);

		return target;
	}

	/**
	 * Translates a Customer domain object into a SimpleCustomerDto dto object. Properties and associations of the domain object
	 * will be mapped to the corresponding properties and associations in the dto object.
	 * To prevent looping while translating biderectional or circulair associations translated objects will be added to the 'translated' register.    
	 *
	 * @param source The {@link Customer} object to translate.
	 *
	 * @return SimpleCustomerDto The {@link SimpleCustomerDto} object translated from source.
	 */
	public SimpleCustomerDto toDto(final Customer source) {
		return toDto(source, new HashMap<Object, Object>());
	}

	SimpleCustomerDto toDto(final Customer source,
			final Map<Object, Object> translated) {
		if (translated.containsKey((source))) {
			return (SimpleCustomerDto) translated.get(source);
		}
		Assert.notNull(source, "argument [source] may not be null");
		SimpleCustomerDto result = new SimpleCustomerDto(source.getId(), source
				.getVersion());
		result.setCustomerNr(source.getCustomerNr());
		result.setLastName(source.getLastName());
		result.setFirstName(source.getFirstName());
		result.setBlackListed(source.isBlackListed());
		result.setUsername(source.getUsername());
		result.setSexe(sexeTranslator.toDto(source.getSexe()));
		result.setBirthDate(source.getBirthDate());

		translated.put(source, result);

		for (Order element : source.getOrders()) {
			result.addToOrders(orderNumberAndDateDtoTranslator.toDto(element,
					translated));
		}

		for (Artist element : source.getIdols()) {
			result.addToIdols(artistDtoTranslator.toDto(element, translated));
		}

		for (Artist element : source.getRelatedTo()) {
			result.addToRelatedTo(disLikesDtoTranslator.toDto(element,
					translated));
		}

		return result;
	}

	/**
	 * Translates a SimpleCustomerDto dto object into a CustomerExample Example domain object. 
	 * All properties in the dto will be mapped to the corresponding property in the <code>target</code> domain object. 
	 * Association references in the dto will not be translated into the <code>target</code> domain object.
	 *
	 * @param source The {@link SimpleCustomerDto} object to translate.
	 *
	 * @return {@link CustomerExample}, the resulting businessclass object.
	 */
	public CustomerExample exampleFromDto(final SimpleCustomerDto source) {
		Assert.notNull(source, "argument [source] may not be null");
		CustomerExample result = new CustomerExample();

		if (source.getCustomerNr() != null) {
			result.setCustomerNr(source.getCustomerNr());
		}
		if (source.getLastName() != null) {
			result.setLastName(source.getLastName());
		}
		if (source.getFirstName() != null) {
			result.setFirstName(source.getFirstName());
		}
		if (source.isBlackListed() != null) {
			result.setBlackListed(source.isBlackListed());
		}
		if (source.getUsername() != null) {
			result.setUsername(source.getUsername());
		}
		if (source.getSexe() != null) {
			result.setSexe(sexeTranslator.fromDto(source.getSexe()));
		}
		if (source.getBirthDate() != null) {
			result.setBirthDate(source.getBirthDate());
		}

		return result;
	}

	/**
	 * Validate that the version of the DTO and the business object are valid.
	 * The DTO may only have a version if the domain object also has a version.
	 * When they both have a version and the DTO version is less, another user
	 * has updated the domain object in the meantime, if it is equal, all is
	 * well. If it is more, an unexpected situation occurs: the DTOs is more new
	 * then the domain object: this is not possible.
	 * 
	 * @param source
	 *            The DTO.
	 * @param target
	 *            The domain object target.
	 */
	private void validateVersion(final SimpleCustomerDto source,
			final Customer target) {
		final Integer sourceVersion = source.getVersion();
		final Integer targetVersion = target.getVersion();

		// FIXME the DTO translator should not know that -1 is the default unpersisted value!
		final boolean equals = (sourceVersion == null)
				? targetVersion == -1
				: sourceVersion.equals(targetVersion);

		if (!equals) {
			throw new ConcurrentUpdateException(
					"Versions of source and target do not match for dto "
							+ source + ", source is " + sourceVersion
							+ ", target is " + targetVersion + ".");
		}
	}
}
